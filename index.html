<!DOCTYPE html>
<html lang="es">
<head>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Editor DTF - Montaje para Impresión</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif}
    body{background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);color:#2d3748;line-height:1.6;min-height:100vh;padding:20px}
    .container{max-width:1400px;margin:0 auto;background:#fff;border-radius:15px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.1)}
    header{background:linear-gradient(135deg,#2c3e50 0%,#4a5568 100%);color:#fff;padding:1.5rem 2rem;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap}
    .logo{font-size:1.8rem;font-weight:700}
    .logo span{color:#4299e1}
    .specs{background:#4a5568;color:#fff;padding:.8rem 1.5rem;border-radius:8px;font-size:.9rem}
    .main-content{display:flex;padding:1rem;gap:1.5rem;min-height:70vh}
    .toolbar,.controls{width:250px;background:#f8f9fa;border-radius:10px;padding:1.5rem;box-shadow:0 4px 6px rgba(0,0,0,.05)}
    .tool-section{margin-bottom:1.5rem;padding-bottom:1.5rem;border-bottom:1px solid #e9ecef}
    .tool-section:last-child{border-bottom:none}
    .tool-section h3{margin-bottom:1rem;color:#2d3748;font-size:1.1rem}
    .btn{display:block;width:100%;padding:.8rem;margin-bottom:.8rem;border:none;border-radius:6px;background:#4299e1;color:#fff;font-weight:500;cursor:pointer;transition:background .3s;text-align:center}
    .btn:hover{background:#3182ce}
    .btn-upload{background:#48bb78}.btn-upload:hover{background:#38a169}
    .btn-download{background:#9f7aea}.btn-download:hover{background:#805ad5}
    .btn-clear{background:#f56565}.btn-clear:hover{background:#e53e3e}
    .canvas-container{flex:1;background:#f8f9fa;border-radius:10px;overflow:hidden;box-shadow:0 4px 6px rgba(0,0,0,.05);padding:1rem;display:flex;flex-direction:column;position:relative}
    .canvas-title{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem}
    .canvas-area{flex:1;background:#fff;border-radius:8px;overflow:auto;display:flex;justify-content:center;align-items:flex-start;padding:1rem;box-shadow:inset 0 0 10px rgba(0,0,0,.05);position:relative}
    #canvas{background:#fff;box-shadow:0 0 20px rgba(0,0,0,.1);touch-action:none;cursor:default}
    .control-group{margin-bottom:1.5rem}
    .control-group h4{margin-bottom:.8rem;color:#2d3748}
    .slider-container{display:flex;align-items:center;gap:10px;margin-bottom:1rem}
    .slider-container span{min-width:40px;text-align:center}
    input[type="range"],input[type="number"]{width:100%}
    .row{display:flex;gap:10px;align-items:center}
    .row>*{flex:1}
    .size-controls{display:flex;gap:10px;margin-bottom:1rem}
    .size-input{flex:1}
    .size-input input{width:100%;padding:.5rem;border:1px solid #cbd5e0;border-radius:4px;text-align:center}
    .size-info{background:#edf2f7;padding:.8rem;border-radius:6px;margin-top:1rem;font-size:.9rem}
    .size-info h4{margin-bottom:.5rem;color:#2d3748}
    .help-section{margin-top:2rem;padding:1rem;background:#edf2f7;border-radius:8px}
    footer{text-align:center;padding:1.5rem;background:#2d3748;color:#fff;margin-top:2rem}
    .instructions{margin-top:1.5rem;padding:1.5rem;background:#edf2f7;border-radius:10px}
    .instructions h3{margin-bottom:1rem;color:#2d3748}
    .instructions ol{padding-left:1.5rem}
    .instructions li{margin-bottom:.8rem}
    .designs-list{max-height:200px;overflow-y:auto;margin-top:1rem;border:1px solid #e2e8f0;border-radius:6px;padding:.5rem}
    .design-item{display:flex;align-items:center;padding:.5rem;margin-bottom:.5rem;background:#fff;border-radius:4px;cursor:pointer;transition:background .2s}
    .design-item:hover{background:#edf2f7}
    .design-item.active{background:#ebf8ff;border:1px solid #90cdf4}
    .design-thumb{width:40px;height:40px;object-fit:cover;border-radius:3px;margin-right:.5rem}
    .proportion-lock{display:flex;align-items:center;margin-bottom:1rem}
    .proportion-lock input{margin-right:.5rem}
    .quality-options{margin-top:1rem}
    .quality-options label{display:block;margin-bottom:.5rem}
    .quality-options select{width:100%;padding:.5rem;border:1px solid #cbd5e0;border-radius:4px}
    .canvas-background{display:flex;align-items:center;gap:10px;margin-bottom:1rem}
    .canvas-background label{white-space:nowrap}
    .canvas-background input{width:30px;height:30px;padding:0;border:1px solid #cbd5e0;border-radius:4px;cursor:pointer}
    .message-container{position:fixed;top:20px;right:20px;z-index:1000;max-width:350px}
    .message{padding:12px 16px;margin-bottom:10px;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,.15);animation:slideIn .3s ease-out;display:flex;align-items:center}
    .message.info{background:#bee3f8;color:#2c5282;border-left:4px solid #2c5282}
    .message.success{background:#c6f6d5;color:#22543d;border-left:4px solid #22543d}
    .message.error{background:#fed7d7;color:#742a2a;border-left:4px solid #742a2a}
    .message.warning{background:#feebcb;color:#744210;border-left:4px solid #744210}
    .message.loading{background:#e9d8fd;color:#553c9a;border-left:4px solid #553c9a}
    .message-icon{margin-right:10px;font-size:18px}
    .close-message{margin-left:auto;background:none;border:none;font-size:18px;cursor:pointer;opacity:.7}
    .close-message:hover{opacity:1}
    @keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}
    @keyframes slideOut{from{transform:translateX(0);opacity:1}to{transform:translateX(100%);opacity:0}}
    @media (max-width:1024px){.main-content{flex-wrap:wrap}.toolbar,.controls{width:100%}.message-container{top:10px;right:10px;left:10px;max-width:none}}

    /* Overlay de contraseña */
    .lock-overlay{position:fixed;inset:0;background:linear-gradient(135deg,#2c3e50 0%,#4a5568 100%);display:flex;align-items:center;justify-content:center;z-index:2000;color:#fff}
    .lock-card{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.25);backdrop-filter:blur(10px);padding:2rem;border-radius:12px;width:min(90vw,380px)}
    .lock-card h2{margin-bottom:1rem}
    .lock-card input{width:100%;padding:.8rem;border-radius:8px;border:none;margin:.5rem 0 1rem 0}
    .lock-card button{width:100%;padding:.8rem;border:none;border-radius:8px;background:#48bb78;color:#fff;font-weight:600;cursor:pointer}
    .lock-error{color:#fed7d7;min-height:1.2em;margin-bottom:.5rem}

    /* --- Pane derecho pegajoso (mínimo cambio) --- */
    .controls{
      position: sticky;
      top: 10px;
      max-height: calc(100vh - 40px);
      overflow: auto;
    }

    /* ====== NUEVO: variable para altura del título ====== */
    :root { --title-h: 0px; }

    /* --- Barra flotante sobre el lienzo --- */
    .floating-tools{
      position: absolute;
      top: calc(10px + var(--title-h)); /* respeta la altura real del título */
      right: 10px;
      z-index: 50;
      display: flex;
      gap: 6px;
      background: rgba(255,255,255,.9);
      border: 1px solid #e2e8f0;
      box-shadow: 0 4px 12px rgba(0,0,0,.08);
      border-radius: 8px;
      padding: 6px;
      backdrop-filter: blur(6px);
      cursor: move;            /* NUEVO: arrastrable */
      user-select: none;       /* NUEVO: evita selección accidental */
      touch-action: none;      /* ayuda en móviles al arrastrar */
    }
    .floating-tools .btn-mini{
      border: 1px solid #cbd5e0;
      background: #edf2f7;
      color: #2d3748;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      line-height: 1;
      white-space: nowrap;
    }
    .floating-tools .btn-mini:hover{
      background:#e2e8f0;
    }
    .floating-tools .sep{
      width:1px; background:#e2e8f0; margin:0 4px;
    }
    @media (max-width: 768px){
      .floating-tools{ right: 6px; left: 6px; justify-content: center; flex-wrap: wrap; }
    }
/* === MOCKUPS === */
/* Capas del mockup (cada diseño es un <img>) */
#mock-layer-host{
  position:absolute; left:0; top:0; right:0; bottom:0;
  pointer-events:none; /* evita bloquear clicks sobre la plantilla */
}
.mock-design{
  position:absolute; left:50%; top:50%;
  transform:translate(-50%,-50%);
  max-width:95%;
  mix-blend-mode:multiply;
  opacity:.95;
  cursor:grab;
  pointer-events:auto;        /* esta sí recibe drag */
}
.mock-design:active{ cursor:grabbing; }

/* Selección visual de la capa activa */
.mock-design.selected{
  outline: 2px dashed #4299e1;
  outline-offset: 2px;
  border-radius: 4px;
}

.mockup-pane{
  display:none;
  background:#f8f9fa;
  border-radius:10px;
  box-shadow:0 4px 6px rgba(0,0,0,.05);
  padding:1rem;
  margin-top:1rem;
}
.mockup-header{
  display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;margin-bottom:12px
}
.mockup-controls{
  display:flex;flex-wrap:wrap;gap:10px;align-items:center
}
.mockup-controls > *{ margin:3px 0; }
<!-- Lista de capas -->
<div id="mock-layers-list" class="designs-list" style="margin-bottom:10px">
  <div class="no-designs">No hay capas aún</div>
</div>
.mockup-stage{
  position:relative;
  width:min(900px, 100%);
  margin:0 auto;
  background:
    linear-gradient(45deg,#eee 25%,transparent 25%),
    linear-gradient(-45deg,#eee 25%,transparent 25%),
    linear-gradient(45deg,transparent 75%,#eee 75%),
    linear-gradient(-45deg,transparent 75%,#eee 75%);
  background-size:20px 20px;
  background-position:0 0,0 10px,10px -10px,-10px 0px;
  border:1px solid #e2e8f0;
  border-radius:8px;
  overflow:hidden;
}
#mock-template{
  display:block;width:100%;height:auto;user-select:none;pointer-events:none;
}
#mock-design{
  position:absolute;left:50%;top:50%;
  transform:translate(-50%,-50%);
  max-width:95%;
  pointer-events:auto; /* para arrastrar */
  mix-blend-mode:multiply; /* por defecto */
  opacity:0.95;
  cursor:grab;
}
#mock-design:active{ cursor:grabbing; }
.mock-btn{ padding:.6rem .8rem;border:none;border-radius:6px;background:#4299e1;color:#fff;cursor:pointer }
.mock-btn:hover{ background:#3182ce }
.mock-select, .mock-input{
  padding:.45rem .6rem;border:1px solid #cbd5e0;border-radius:6px;background:#fff
}
.mock-slider{ width:160px }
  </style>
</head>
<body>
  <!-- Overlay de contraseña -->
  <div class="lock-overlay" id="lock-overlay" style="display:none;">
    <div class="lock-card">
      <h2>Acceso restringido</h2>
      <p>Ingresa la contraseña para ver el editor.</p>
      <input type="password" id="lock-pass" placeholder="Contraseña" autocomplete="current-password">
      <div class="lock-error" id="lock-error"></div>
      <button id="lock-btn">Acceder</button>
    </div>
  </div>

  <div class="container" id="app-root" style="visibility:hidden;">
    <header>
      <div class="logo">Editor DTF <span>By: David Munive</span></div>
      <div class="specs" id="specs-label">Lienzo: 58cm × 100cm | Formato: PNG/PDF</div>
    </header>

    <div class="main-content">
      <!-- Toolbar izquierda -->
      <div class="toolbar">
        <div class="tool-section">
          <h3>Gestión de Diseños</h3>
          <input type="file" id="file-input" accept="image/*" style="display:none" multiple>
          <button class="btn btn-upload" id="upload-btn">⬆️ Subir Diseño(s)</button>
          <button class="btn" id="add-text-btn">✏️ Agregar Texto</button>
          <button class="btn" id="remove-bg-btn">🪄 Quitar fondo (Beta)</button>
          <button class="btn" id="open-mockups">🧥 Abrir Mockups</button>


          <div class="canvas-background">
            <label for="canvas-color">Color de fondo:</label>
            <input type="color" id="canvas-color" value="#ffffff">
          </div>

          <div class="designs-list" id="designs-list">
            <div class="no-designs">No hay diseños cargados</div>
          </div>
        </div>

        <div class="tool-section">
          <h3>Opciones de Exportación</h3>
          <div class="quality-options">
            <label for="quality-select">Resolución de exportación:</label>
            <select id="quality-select">
              <option value="300">Alta (300 DPI)</option>
              <option value="150" selected>Media (150 DPI)</option>
              <option value="72">Baja (72 DPI)</option>
            </select>
          </div>
          <button class="btn btn-download" id="download-png">💾 Descargar PNG</button>
          <button class="btn btn-download" id="download-pdf">📄 Descargar PDF</button>
          <button class="btn btn-clear" id="clear-btn">🧹 Limpiar Lienzo</button>
        </div>

        <div class="instructions">
          <h3>Instrucciones</h3>
          <ol>
            <li>Sube tus diseños con el botón "Subir Diseño"</li>
            <li>Selecciona un diseño de la lista para editarlo</li>
            <li>Arrastra para mover, usa los controles para redimensionar y rotar</li>
            <li>Las dimensiones se muestran en centímetros</li>
            <li>Descarga tu montaje en PNG o PDF</li>
          </ol>
          <p class="help-section">
            <strong>Nota:</strong> El color de fondo es solo para visualización.
            Las exportaciones mantendrán la transparencia.
          </p>
        </div>
      </div>

      <!-- Canvas central -->
      <div class="canvas-container">
        <!-- Barra flotante (accesos rápidos) -->
        <div class="floating-tools" id="floating-tools" title="Doble click para volver a posición inicial">
          <button class="btn-mini" data-target="mirror-btn">🪞 Espejo</button>
          <span class="sep"></span>
          <button class="btn-mini" data-target="send-back" title="Al fondo">⤵️ Fondo</button>
          <button class="btn-mini" data-target="step-back" title="Un paso atrás">⬇️ Atrás</button>
          <button class="btn-mini" data-target="step-forward" title="Un paso adelante">⬆️ Adelante</button>
          <button class="btn-mini" data-target="bring-front" title="Al frente">⤴️ Frente</button>
          <span class="sep"></span>
          <button class="btn-mini" data-target="remove-btn" title="Eliminar">🗑️ Eliminar</button>
        </div>

        <div class="canvas-title">
          <h3>Área de Montaje (<span id="canvas-size-label">58cm × 100cm</span>)</h3>
          <div id="zoom-level">Zoom: 100%</div>
        </div>
        <div class="canvas-area">
          <div class="canvas-wrapper" id="canvas-wrapper" style="width:580px;height:1000px;
            background-image:
              linear-gradient(45deg,#f0f0f0 25%,transparent 25%),
              linear-gradient(-45deg,#f0f0f0 25%,transparent 25%),
              linear-gradient(45deg,transparent 75%,#f0f0f0 75%),
              linear-gradient(-45deg,transparent 75%,#f0f0f0 75%);
            background-size:20px 20px;
            background-position:0 0,0 10px,10px -10px,-10px 0px;">
            <canvas id="canvas" width="580" height="1000"></canvas>
          </div>
        </div>
      </div>
<!-- ===== MOCKUPS: panel ===== -->
<div class="mockup-pane" id="mockup-pane">
  <div class="mockup-header">
    <h3>Mockups de Camiseta</h3>
    <div class="mockup-controls">
      <!-- Plantilla (elige tu camiseta de imgbb) -->
      <select id="mock-template-select" class="mock-select" title="Plantilla de camiseta"></select>

      <!-- Color/mezcla y opacidad -->
      <select id="mock-blend" class="mock-select" title="Modo de fusión">
        <option value="normal" selected>Normal</option>
        <option value="multiply">Multiply</option>
        <option value="screen">Screen</option>
        <option value="overlay">Overlay</option>
        <option value="darken">Darken</option>
        <option value="lighten">Lighten</option>
      </select>

      <label>Opacidad
        <input type="range" id="mock-opacity" class="mock-slider" min="10" max="100" value="95">
      </label>

      <!-- Escala / Rotación -->
      <label>Escala
        <input type="range" id="mock-scale" class="mock-slider" min="10" max="300" value="100">
      </label>
      <label>Rotación
        <input type="range" id="mock-rot" class="mock-slider" min="0" max="360" value="0">
      </label>

      <!-- Cargar diseño para mockup -->
      <input type="file" id="mock-file" accept="image/*" style="display:none">
      <button class="mock-btn" id="mock-use-selected">Añadir desde editor</button>
<button class="mock-btn" id="mock-upload">Subir diseño</button>
<button class="mock-btn" id="mock-delete">Eliminar capa</button>
<button class="mock-btn" id="mock-front">Al frente</button>
<button class="mock-btn" id="mock-back">Al fondo</button>
<button class="mock-btn" id="mock-download">Descargar PNG</button>

      <!-- Cerrar -->
      <button class="mock-btn" id="mock-close">Cerrar</button>
    </div>
  </div>

  <div class="mockup-stage" id="mock-stage">
    <img id="mock-template" alt="Plantilla camiseta">
    <!-- Host de capas (múltiples diseños) -->
    <div id="mock-layer-host"></div>
  </div>
</div>
<!-- ===== /MOCKUPS: panel ===== -->

      <!-- Panel derecho (controles) -->
      <div class="controls">
        <!-- Alto del lienzo (arriba) -->
        <div class="control-group">
          <h4>Alto del lienzo (cm)</h4>
          <div class="row">
            <input type="number" id="canvas-height-cm" min="10" max="100" step="0.5" value="100" title="Alto en cm (máx. 100)">
            <button class="btn" id="apply-canvas-height">Aplicar alto</button>
          </div>
          <small>El ancho permanece en 58 cm. Máximo 100 cm de alto.</small>
        </div>

        <!-- Zoom del lienzo (debajo del alto) -->
        <div class="control-group">
          <h4>Zoom del Lienzo</h4>
          <div class="slider-container">
            <span id="zoom-value">100%</span>
            <input type="range" id="zoom-slider" min="20" max="200" value="100">
          </div>
          <small>Tip: Ctrl (Win/Linux) o ⌘ (Mac) + rueda.</small>
        </div>

        <div class="tool-section">
          <h3>Controles de Diseño</h3>

          <div class="control-group">
            <h4>Rotación</h4>
            <div class="row">
              <div>
                <div class="slider-container">
                  <span id="rotation-value">0°</span>
                  <input type="range" id="rotation-slider" min="0" max="360" value="0">
                </div>
              </div>
              <input type="number" id="rotation-input" min="0" max="360" step="1" value="0" title="Rotación (°)">
            </div>
          </div>

          <div class="control-group">
            <h4>Opacidad</h4>
            <div class="slider-container">
              <span id="opacity-value">100%</span>
              <input type="range" id="opacity-slider" min="10" max="100" value="100">
            </div>
          </div>

          <div class="control-group">
            <h4>Tamaño Manual (cm)</h4>
            <div class="proportion-lock">
              <input type="checkbox" id="lock-proportion" checked>
              <label for="lock-proportion">Mantener proporción</label>
            </div>
            <div class="size-controls">
              <div class="size-input">
                <label>Ancho</label>
                <input type="number" id="width-input" min="1" step="0.1" value="0">
              </div>
              <div class="size-input">
                <label>Alto</label>
                <input type="number" id="height-input" min="1" step="0.1" value="0">
              </div>
            </div>
            <button class="btn" id="apply-size">Aplicar Tamaño</button>
          </div>

          <div class="size-info">
            <h4>Dimensiones del diseño</h4>
            <div id="size-info">0cm × 0cm</div>
            <div id="original-size">Tamaño original: 0cm × 0cm</div>
          </div>

          <!-- HERRAMIENTAS EXTRA -->
          <div class="control-group">
            <h4>Herramientas</h4>
            <button class="btn" id="mirror-btn">🪞 Espejo (Horizontal)</button>
          </div>

          <div class="control-group">
            <h4>Orden (Z-order)</h4>
            <div class="row">
              <button class="btn" id="send-back">⤵️ Al fondo</button>
              <button class="btn" id="step-back">⬇️ Atrás</button>
            </div>
            <div class="row" style="margin-top:.5rem">
              <button class="btn" id="step-forward">⬆️ Adelante</button>
              <button class="btn" id="bring-front">⤴️ Al frente</button>
            </div>
          </div>

          <button class="btn btn-clear" id="remove-btn">🗑️ Eliminar Diseño</button>
        </div>

        <div class="help-section">
          <h4>Atajos</h4>
          <p>• Supr/Backspace: eliminar seleccionado</p>
          <p>• Flechas: mover (Shift = 10 px)</p>
          <p>• Ctrl/Cmd + D: duplicar seleccionado</p>
          <p>• Ctrl o ⌘ + rueda: zoom</p>
        </div>
      </div>
    </div>

    <footer>
      <p>Editor de Montajes para Impresión DTF</p>
    </footer>
  </div>

  <!-- Mensajes -->
  <div class="message-container" id="message-container"></div>

  <!-- Librerías -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    // ====== Seguridad (Contraseña) ======
    const ACCESS_PASSWORD = 'dtf2025'; // <-- cámbiala aquí
    const overlay = document.getElementById('lock-overlay');
    const appRoot = document.getElementById('app-root');
    const lockBtn = document.getElementById('lock-btn');
    const lockPass = document.getElementById('lock-pass');
    const lockError = document.getElementById('lock-error');

    function showLock(){
      overlay.style.display = 'flex';
      appRoot.style.visibility = 'hidden';
      setTimeout(()=> lockPass && lockPass.focus(), 0);
    }
    function unlock(){
      overlay.style.display = 'none';
      appRoot.style.visibility = 'visible';
    }
    if (sessionStorage.getItem('dtf_unlocked') === '1') {
      unlock();
    } else {
      showLock();
    }
    if (lockBtn) lockBtn.addEventListener('click', tryUnlock);
    if (lockPass) lockPass.addEventListener('keydown', e => { if (e.key === 'Enter') tryUnlock(); });
    function tryUnlock(){
      if (!lockPass) return;
      if (lockPass.value === ACCESS_PASSWORD){
        sessionStorage.setItem('dtf_unlocked','1');
        unlock();
      } else {
        lockError.textContent = 'Contraseña incorrecta';
      }
    }

    // ====== Referencias DOM
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const uploadBtn = document.getElementById('upload-btn');
    const fileInput = document.getElementById('file-input');
    const clearBtn = document.getElementById('clear-btn');
    const downloadPngBtn = document.getElementById('download-png');
    const downloadPdfBtn = document.getElementById('download-pdf');
    const rotationSlider = document.getElementById('rotation-slider');
    const rotationValue = document.getElementById('rotation-value');
    const rotationInput = document.getElementById('rotation-input');
    const opacitySlider = document.getElementById('opacity-slider');
    const opacityValue = document.getElementById('opacity-value');
    const zoomSlider = document.getElementById('zoom-slider');
    const zoomValue = document.getElementById('zoom-value');
    const zoomLevel = document.getElementById('zoom-level');
    const addTextBtn = document.getElementById('add-text-btn');
    const designsList = document.getElementById('designs-list');
    const removeBtn = document.getElementById('remove-btn');
    const sizeInfo = document.getElementById('size-info');
    const originalSizeInfo = document.getElementById('original-size');
    const widthInput = document.getElementById('width-input');
    const heightInput = document.getElementById('height-input');
    const applySizeBtn = document.getElementById('apply-size');
    const lockProportion = document.getElementById('lock-proportion');
    const qualitySelect = document.getElementById('quality-select');
    const canvasColor = document.getElementById('canvas-color');
    const messageContainer = document.getElementById('message-container');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    const specsLabel = document.getElementById('specs-label');
    const canvasSizeLabel = document.getElementById('canvas-size-label');
    const canvasHeightInput = document.getElementById('canvas-height-cm');
    const applyCanvasHeightBtn = document.getElementById('apply-canvas-height');

    // Botones añadidos (ya presentes en el HTML)
    const mirrorBtn = document.getElementById('mirror-btn');
    const bringFrontBtn = document.getElementById('bring-front');
    const sendBackBtn = document.getElementById('send-back');
    const stepForwardBtn = document.getElementById('step-forward');
    const stepBackBtn = document.getElementById('step-back');
    const removeBgBtn = document.getElementById('remove-bg-btn');

    // ====== Constantes físicas
    const PIXELS_PER_CM = 10; // 10 px = 1 cm (580px/58cm)
    const CANVAS_WIDTH_CM = 58; // fijo
    let CANVAS_HEIGHT_CM = 100; // variable (máx 100)
    const INCHES_PER_CM = 0.3937007874;
   
 // ====== U2NET (quita fondo beta)
    const U2NET_MODEL_PATH = 'models/silueta.onnx';
    let u2netSession = null;
    let u2netLoading = false;


    // ====== Estado
    let designs = [];
    let selectedDesignId = null;
    let isDragging = false;
    let isResizing = false;
    let isRotating = false;
    let dragOffsetX, dragOffsetY;
    let canvasZoom = 1.0;
    let lastMouseX, lastMouseY;
    let startScale = 1.0;
    let startResizeDist = 1.0;
    let canvasBackgroundColor = '#ffffff';

    // ====== Mensajes flotantes
    function showMessage(message, type = 'info', duration = 5000) {
      const messageEl = document.createElement('div');
      messageEl.className = `message ${type}`;
      const icons = { info:'ℹ️', success:'✅', error:'❌', warning:'⚠️', loading:'⏳' };
      messageEl.innerHTML = `
        <span class="message-icon">${icons[type] || icons.info}</span>
        <span>${message}</span>
        <button class="close-message">&times;</button>`;
      messageContainer.appendChild(messageEl);
      const closeBtn = messageEl.querySelector('.close-message');
      function close(){
        messageEl.style.animation='slideOut .3s ease-out';
        setTimeout(()=> messageEl.remove(), 300);
      }
      if (closeBtn) closeBtn.addEventListener('click', close);
      if (duration>0) setTimeout(()=> messageEl && close(), duration);
      return messageEl;
    }

    // ====== Fondo y guía
    function initCanvas() {
      ctx.save();
      ctx.clearRect(0,0,canvas.width,canvas.height);

        // patrón de transparencia optimizado
  const size = 20;
  const patternCanvas = document.createElement('canvas');
  patternCanvas.width = size * 2;
  patternCanvas.height = size * 2;
  const pctx = patternCanvas.getContext('2d');

  // pinta 2 cuadros grises en diagonal
  pctx.fillStyle = '#f0f0f0';
  pctx.fillRect(0, 0, size, size);
  pctx.fillRect(size, size, size, size);

  const pattern = ctx.createPattern(patternCanvas, 'repeat');
  ctx.fillStyle = pattern;
  ctx.fillRect(0, 0, canvas.width, canvas.height);


      // capa de color (solo visual)
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = canvasBackgroundColor;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.globalAlpha = 1.0;

      // borde área de impresión
      ctx.strokeStyle = '#cbd5e0';
      ctx.lineWidth = 2;
      ctx.setLineDash([5,5]);
      ctx.strokeRect(5,5, canvas.width-10, canvas.height-10);
      ctx.setLineDash([]);

      // texto guía
      if (designs.length===0){
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('BY: DAVID MUNIVE', canvas.width/2, canvas.height/2);
      }
      ctx.restore();
    }

    initCanvas();

   // ====== Clase Design
class Design {
  constructor(id, image, x, y) {
    this.id = id;
    this.image = image;
    this.x = x || canvas.width/2;
    this.y = y || canvas.height/2;
    this.scale = 1.0;
    this.rotation = 0;
    this.opacity = 1.0;
    this.width = image.width;
    this.height = image.height;
    this.aspectRatio = image.width / image.height;
    this.originalWidth = image.width;
    this.originalHeight = image.height;
  }

  draw() {
    ctx.save();
    ctx.globalAlpha = this.opacity;
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation * Math.PI / 180);
    ctx.scale(this.scale, this.scale);

    const width = this.width;
    const height = this.height;

    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(this.image, -width/2, -height/2, width, height);

    if (this.id === selectedDesignId) {
      // borde del seleccionado
      ctx.strokeStyle = '#4299e1';
      ctx.lineWidth = 2;
      ctx.strokeRect(-width/2, -height/2, width, height);

      // centro
      ctx.fillStyle = '#4299e1';
      ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill();

      // handle rotación (arriba)
      ctx.fillStyle = '#48bb78';
      ctx.beginPath(); ctx.arc(0, -height/2 - 15, 6, 0, Math.PI*2); ctx.fill();

      // handle escala (esquina inferior derecha)
      ctx.fillStyle = '#f56565';
      ctx.beginPath(); ctx.arc(width/2 + 5, height/2 + 5, 6, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  getDimensionsInCm() {
    return {
      width:  (this.width  * this.scale) / PIXELS_PER_CM,
      height: (this.height * this.scale) / PIXELS_PER_CM
    };
  }

  getOriginalDimensionsInCm() {
    return {
      width:  (this.originalWidth)  / PIXELS_PER_CM,
      height: (this.originalHeight) / PIXELS_PER_CM
    };
  }

  setDimensions(widthCm, heightCm, maintainProportion = true) {
    const targetWidthPx  = widthCm  * PIXELS_PER_CM;
    const targetHeightPx = heightCm * PIXELS_PER_CM;

    if (maintainProportion) {
      this.scale = targetWidthPx / this.originalWidth;
    } else {
      const scaleX = targetWidthPx  / this.originalWidth;
      const scaleY = targetHeightPx / this.originalHeight;
      this.scale = (scaleX + scaleY) / 2;
    }
    this.updateInputs();
    drawCanvas();
  }

  updateInputs() {
    const d = this.getDimensionsInCm();
    widthInput.value = d.width.toFixed(1);
    heightInput.value = d.height.toFixed(1);
  }

  isPointInside(x, y) {
    const width = this.width * this.scale;
    const height = this.height * this.scale;

    // punto relativo al centro del diseño
    const relX = x - this.x;
    const relY = y - this.y;

    // "des-rotamos" el punto
    const angle = -this.rotation * Math.PI/180;
    const rx = relX * Math.cos(angle) - relY * Math.sin(angle);
    const ry = relX * Math.sin(angle) + relY * Math.cos(angle);

    // ¿está dentro del rectángulo?
    return Math.abs(rx) <= width/2 && Math.abs(ry) <= height/2;
  }

  isRotationHandle(x, y) {
    const width  = this.width * this.scale;
    const height = this.height * this.scale;

    // punto relativo al centro
    const relX = x - this.x;
    const relY = y - this.y;

    // "des-rotamos" el punto
    const angle = -this.rotation * Math.PI / 180;
    const rx = relX * Math.cos(angle) - relY * Math.sin(angle);
    const ry = relX * Math.sin(angle) + relY * Math.cos(angle);

    // handle de rotación centrado arriba
    const hx = 0;
    const hy = -height / 2 - 15;

    // radio 10px
    return Math.hypot(rx - hx, ry - hy) <= 10;
  }

  isScaleHandle(x, y) {
    const width  = this.width * this.scale;
    const height = this.height * this.scale;

    // punto relativo al centro
    const relX = x - this.x;
    const relY = y - this.y;

    // "des-rotamos" el punto
    const angle = -this.rotation * Math.PI / 180;
    const rx = relX * Math.cos(angle) - relY * Math.sin(angle);
    const ry = relX * Math.sin(angle) + relY * Math.cos(angle);

    // handle de escala en la esquina inferior derecha
    const hx = width / 2 + 5;
    const hy = height / 2 + 5;

    // radio 10px
    return Math.hypot(rx - hx, ry - hy) <= 10;
  }
}

  
// === Quitar Fondo (Beta) – funciones globales ===
// Usa el modelo que ya tienes en U2NET_MODEL_PATH (silueta.onnx). No cambies eso.

// === Quitar Fondo (Beta) – funciones globales ===
// ...
let u2netReadyPromise = null; // <- NUEVO

async function loadU2NetModel() {
  if (typeof ort === 'undefined') {
    showMessage('Falta la librería del modelo (ort.min.js).', 'error', 6000);
    throw new Error('onnxruntime-web no cargado');
  }
  if (u2netSession) return u2netSession;           // ya cargado
  if (u2netReadyPromise) return u2netReadyPromise; // ya cargándose: esperar

  showMessage('Cargando modelo de recorte...', 'loading', 0);

  u2netReadyPromise = ort.InferenceSession.create(U2NET_MODEL_PATH, {
    executionProviders: ['webgl', 'wasm'],
    graphOptimizationLevel: 'all'
  })
  .then(session => {
    u2netSession = session;
    showMessage('Modelo listo ✅', 'success', 1200);
    return session;
  })
  .catch(err => {
    showMessage('No se pudo cargar el modelo: ' + err.message, 'error', 6000);
    u2netReadyPromise = null; // permitir reintentar
    throw err;
  });

  return u2netReadyPromise;
}


// --- Utilidades ---

// Umbral de Otsu (0..1) sobre una imagen en escala de grises (canal R)
function otsuThresholdFromImageData(imgData) {
  const data = imgData.data;
  const hist = new Array(256).fill(0);
  for (let i=0; i<data.length; i+=4) hist[data[i]]++;
  const total = imgData.width * imgData.height;
  let sum = 0;
  for (let t=0; t<256; t++) sum += t * hist[t];
  let sumB = 0, wB = 0, wF = 0, mB = 0, mF = 0, maxVar = -1, threshold = 0;
  for (let t=0; t<256; t++) {
    wB += hist[t];
    if (wB === 0) continue;
    wF = total - wB;
    if (wF === 0) break;
    sumB += t * hist[t];
    mB = sumB / wB;
    mF = (sum - sumB) / wF;
    const between = wB * wF * (mB - mF) * (mB - mF);
    if (between > maxVar) { maxVar = between; threshold = t; }
  }
  return threshold / 255;
}

// Operaciones morfológicas muy básicas sobre una máscara binaria (0/255)
function morph(maskCtx, w, h, type /*'erode'|'dilate'*/) {
  const src = maskCtx.getImageData(0,0,w,h);
  const dst = maskCtx.createImageData(w,h);
  const S = src.data, D = dst.data;

  // kernel 3x3
  const get = (x,y) => {
    if (x<0 || y<0 || x>=w || y>=h) return 0;
    const i = (y*w + x) * 4;
    return S[i]; // rojo (R=G=B)
  };

  for (let y=0; y<h; y++){
    for (let x=0; x<w; x++){
      let val;
      if (type === 'dilate') {
        // si algún vecino es 255 => 255
        val = 0;
        for (let j=-1;j<=1;j++) for (let i=-1;i<=1;i++) val = Math.max(val, get(x+i, y+j));
      } else {
        // si todos vecinos 255 => 255
        val = 255;
        for (let j=-1;j<=1;j++) for (let i=-1;i<=1;i++) val = Math.min(val, get(x+i, y+j));
      }
      const k = (y*w + x) * 4;
      D[k]=D[k+1]=D[k+2]=val; D[k+3]=255;
    }
  }
  maskCtx.putImageData(dst, 0, 0);
}

// Mantener solo el componente conectado más grande (el sujeto principal)
function keepLargestComponent(maskCtx, w, h) {
  const img = maskCtx.getImageData(0,0,w,h);
  const data = img.data;
  const visited = new Uint8Array(w*h);
  const idx = (x,y)=> y*w + x;

  let bestArea = 0, bestLabel = -1, label = 1;
  const labels = new Int32Array(w*h);

  // BFS flood fill para etiquetar componentes (pixeles == 255)
  const qx = new Int32Array(w*h), qy = new Int32Array(w*h);
  for (let y=0; y<h; y++){
    for (let x=0; x<w; x++){
      const i = idx(x,y);
      if (visited[i]) continue;
      const v = data[i*4]; // R
      if (v !== 255) { visited[i]=1; continue; }
      let front = 0, back = 0, area = 0;
      qx[back]=x; qy[back]=y; back++;
      visited[i]=1;
      labels[i] = label;
      while (front<back){
        const cx = qx[front], cy = qy[front]; front++;
        area++;
        // 4-vecinos
        const N = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dx,dy] of N){
          const nx=cx+dx, ny=cy+dy;
          if (nx<0||ny<0||nx>=w||ny>=h) continue;
          const ni = idx(nx,ny);
          if (visited[ni]) continue;
          if (data[ni*4] === 255){
            visited[ni]=1; labels[ni]=label;
            qx[back]=nx; qy[back]=ny; back++;
          } else visited[ni]=1;
        }
      }
      if (area > bestArea){ bestArea = area; bestLabel = label; }
      label++;
    }
  }
  // borrar todo lo que no sea el mayor
  for (let i=0; i<w*h; i++){
    const keep = (labels[i] === bestLabel) ? 255 : 0;
    data[i*4]=data[i*4+1]=data[i*4+2]=keep; data[i*4+3]=255;
  }
  maskCtx.putImageData(img, 0, 0);
}

// Binarizar + limpiar + feather
function refineMask(maskCanvas, opts) {
  const { threshold='auto', clean=1, feather=2 } = opts || {};
  const w = maskCanvas.width, h = maskCanvas.height;
  const ctx = maskCanvas.getContext('2d');

  // 1) binarizar
  const img = ctx.getImageData(0,0,w,h);
  const thr = (threshold === 'auto')
    ? otsuThresholdFromImageData(img)
    : Math.max(0, Math.min(1, threshold));
  for (let i=0; i<img.data.length; i+=4){
    const v = img.data[i]/255;
    const bin = v >= thr ? 255 : 0;
    img.data[i]=img.data[i+1]=img.data[i+2]=bin; img.data[i+3]=255;
  }
  ctx.putImageData(img, 0, 0);

  // 2) cerrar pequeños huecos y suciedad
  for (let k=0; k<clean; k++) { morph(ctx,w,h,'dilate'); morph(ctx,w,h,'erode'); }

  // 3) mantener solo el componente principal (evita “islas”)
  keepLargestComponent(ctx, w, h);

  // 4) feather (suaviza borde)
  if (feather>0){
    const soft = document.createElement('canvas');
    soft.width = w; soft.height = h;
    const sctx = soft.getContext('2d');
    sctx.filter = `blur(${feather}px)`;
    sctx.drawImage(maskCanvas, 0, 0);
    sctx.filter = 'none';
    const g = sctx.getImageData(0,0,w,h);
    ctx.putImageData(g, 0, 0);
  }
}


// Ejecuta el modelo al tamaño que espera (detectado desde la sesión; por defecto 320)
async function predictMaskAtSize(img) {
  await loadU2NetModel();

  // 1) Detectar tamaño de entrada del modelo (ej. 320)
  const inputName = u2netSession.inputNames[0];
  let side = 320; // fallback
  try {
    const meta = u2netSession.inputMetadata?.[inputName];
    const dims = meta?.dimensions; // [1,3,320,320]
    if (Array.isArray(dims) && dims.length === 4) {
      const h = typeof dims[2] === 'number' ? dims[2] : 320;
      const w = typeof dims[3] === 'number' ? dims[3] : 320;
      side = Math.max(h, w) || 320;
    }
  } catch (_) {}

  // 2) Preprocesado con “marcos” (padding) sin deformar
  const tmp = document.createElement('canvas');
  tmp.width = side; tmp.height = side;
  const tctx = tmp.getContext('2d');

  const scale = Math.min(side / img.width, side / img.height);
  const nw = Math.max(1, Math.round(img.width * scale));
  const nh = Math.max(1, Math.round(img.height * scale));
  const ox = Math.floor((side - nw) / 2);
  const oy = Math.floor((side - nh) / 2);

  tctx.clearRect(0,0,side,side);
  tctx.imageSmoothingEnabled = true;
  tctx.imageSmoothingQuality = 'high';
  tctx.drawImage(img, ox, oy, nw, nh);

  // 3) A tensor CHW float32 0..1
  const src = tctx.getImageData(0,0,side,side).data;
  const tData = new Float32Array(1 * 3 * side * side);
  for (let i=0, p=0; i<src.length; i+=4, p++){
    tData[p]                   = src[i]   / 255;        // R
    tData[p + side*side]       = src[i+1] / 255;        // G
    tData[p + 2*side*side]     = src[i+2] / 255;        // B
  }

  const feeds = { [inputName]: new ort.Tensor('float32', tData, [1,3,side,side]) };
  const outputs = await u2netSession.run(feeds);
  const outName = u2netSession.outputNames?.[0] || Object.keys(outputs)[0];
  const out = outputs[outName]; // dims [1,1,side,side]; data 0..1

  // 4) Pasar a máscara gris 0..255
  const maskSide = document.createElement('canvas');
  maskSide.width = side; maskSide.height = side;
  const mctx = maskSide.getContext('2d');
  const imgOut = mctx.createImageData(side, side);
  for (let i=0; i<side*side; i++){
    const g = Math.round(Math.max(0, Math.min(1, out.data[i])) * 255);
    imgOut.data[i*4+0]=g; imgOut.data[i*4+1]=g; imgOut.data[i*4+2]=g; imgOut.data[i*4+3]=255;
  }
  mctx.putImageData(imgOut, 0, 0);

  // 5) Recortar padding y reescalar al tamaño original
  const crop = document.createElement('canvas');
  crop.width = nw; crop.height = nh;
  const cctx = crop.getContext('2d');
  cctx.imageSmoothingEnabled = true;
  cctx.imageSmoothingQuality = 'high';
  cctx.drawImage(maskSide, ox, oy, nw, nh, 0, 0, nw, nh);

  const maskFull = document.createElement('canvas');
  maskFull.width = img.width; maskFull.height = img.height;
  const fctx = maskFull.getContext('2d');
  fctx.imageSmoothingEnabled = true;
  fctx.imageSmoothingQuality = 'high';
  fctx.drawImage(crop, 0, 0, img.width, img.height);

  return maskFull;
}


// Aplica la máscara (gris 0..255) como alfa a la imagen original
function applyMaskToImage(img, maskCanvas) {
  const outCanvas = document.createElement('canvas');
  outCanvas.width = img.width; outCanvas.height = img.height;
  const octx = outCanvas.getContext('2d');
  octx.drawImage(img, 0, 0);
  const rgba = octx.getImageData(0,0,img.width,img.height);
  const mctx = maskCanvas.getContext('2d');
  const mdata = mctx.getImageData(0,0,img.width,img.height).data;
  for (let i=0, j=0; i<rgba.data.length; i+=4, j++){
    rgba.data[i+3] = mdata[i]; // usar R como alfa
  }
  octx.putImageData(rgba, 0, 0);
  return outCanvas;
}


// === Función principal: una pasada al tamaño del modelo ===
async function removeBackgroundFromImage(img, opts) {
  const options = Object.assign({ threshold: 'auto', clean: 1, feather: 2 }, opts || {});

  // Una sola inferencia al tamaño que admite el modelo (ej. 320)
  const mask = await predictMaskAtSize(img);

  // Refinar (umbral, limpieza morfológica y feather)
  refineMask(mask, options);

  // Aplicar máscara como alfa
  return applyMaskToImage(img, mask);
}


    // ====== Dibujo general
    function drawCanvas() {
      initCanvas();
      designs.forEach(d => d.draw());
      updateSizeInfo();
    }

    function updateSizeInfo() {
      const d = getSelectedDesign();
      if (d) {
        const c = d.getDimensionsInCm();
        const o = d.getOriginalDimensionsInCm();
        sizeInfo.textContent = `${c.width.toFixed(1)}cm × ${c.height.toFixed(1)}cm`;
        originalSizeInfo.textContent = `Tamaño original: ${o.width.toFixed(1)}cm × ${o.height.toFixed(1)}cm`;
      } else {
        sizeInfo.textContent = '0cm × 0cm';
        originalSizeInfo.textContent = 'Tamaño original: 0cm × 0cm';
      }
    }

    // ====== Exportación
    function getPixelDimensions(dpi) {
      const widthPx  = Math.round(CANVAS_WIDTH_CM  * INCHES_PER_CM * dpi);
      const heightPx = Math.round(CANVAS_HEIGHT_CM * INCHES_PER_CM * dpi);
      return { width: widthPx, height: heightPx };
    }

    function createHighQualityCanvas() {
      const dpi = parseInt(qualitySelect.value);
      const dim = getPixelDimensions(dpi);

      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = dim.width;
      exportCanvas.height = dim.height;
      const ectx = exportCanvas.getContext('2d');

      ectx.imageSmoothingEnabled = true;
      ectx.imageSmoothingQuality = 'high';

      const scaleX = exportCanvas.width / canvas.width;
      const scaleY = exportCanvas.height / canvas.height;

      ectx.clearRect(0,0,exportCanvas.width,exportCanvas.height);

      designs.forEach(design => {
        ectx.save();
        ectx.globalAlpha = design.opacity;

        const x = design.x * scaleX;
        const y = design.y * scaleY;
        const scale = design.scale * Math.min(scaleX, scaleY);

        ectx.translate(x, y);
        ectx.rotate(design.rotation * Math.PI/180);
        ectx.scale(scale, scale);

        const w = design.width;
        const h = design.height;
        ectx.drawImage(design.image, -w/2, -h/2, w, h);

        ectx.restore();
      });

      return exportCanvas;
    }

    // ====== UI: color de fondo
    if (canvasColor){
      canvasColor.addEventListener('input', function(){
        canvasBackgroundColor = this.value;
        drawCanvas();
        showMessage(`Color de fondo cambiado a ${this.value}`, 'info', 2000);
      });
    }

    // ====== Upload (permitir subir el mismo archivo)
    if (uploadBtn){
      uploadBtn.addEventListener('click', ()=>{
        if (fileInput) fileInput.value = '';
        if (fileInput) fileInput.click();
      });
    }

    if (fileInput){
      fileInput.addEventListener('change', function(e){
        if (e.target.files && e.target.files.length>0){
          const files = Array.from(e.target.files);
          let loaded = 0;
          const total = files.length;
          const loadingMsg = showMessage(`Cargando ${total} diseño(s)...`,'loading',0);

          files.forEach(file=>{
            if (!file.type.match('image.*')){
              showMessage(`Error: ${file.name} no es una imagen válida`,'error');
              if (++loaded===total) loadingMsg.remove();
              return;
            }
            const reader = new FileReader();
            reader.onload = function(ev){
              const img = new Image();
              img.onload = function(){
                const id = 'design-' + Date.now() + Math.random().toString(36).slice(2,7);
                const d = new Design(id, img);

                const maxW = canvas.width - 20;
                const maxH = canvas.height - 20;
                const scaleToFit = Math.min(maxW / d.width, maxH / d.height);
                d.scale = Math.min(1, scaleToFit);

                designs.push(d);
                selectedDesignId = id;

                if (++loaded===total) { loadingMsg.remove(); showMessage(`${total} diseño(s) cargado(s)`,'success'); }
                updateDesignsList();
                updateControls();
                drawCanvas();
              };
              img.onerror = function(){
                if (++loaded===total) loadingMsg.remove();
                showMessage(`Error al cargar la imagen: ${file.name}`,'error');
              }
              img.src = ev.target.result;
            };
            reader.onerror = function(){
              if (++loaded===total) loadingMsg.remove();
              showMessage(`Error al leer: ${file.name}`,'error');
            }
            reader.readAsDataURL(file);
          });

          fileInput.value = '';
        }
      });
    }

    // ====== Lista de diseños
    function updateDesignsList(){
      designsList.innerHTML = '';
      if (designs.length===0){
        designsList.innerHTML = '<div class="no-designs">No hay diseños cargados</div>';
        return;
      }
      designs.forEach(design=>{
        const item = document.createElement('div');
        item.className = 'design-item' + (design.id===selectedDesignId ? ' active' : '');
        item.dataset.id = design.id;

        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = 40; thumbCanvas.height = 40;
        const tctx = thumbCanvas.getContext('2d');
        const scale = Math.min(40/design.width, 40/design.height) * 0.8;
        tctx.fillStyle = '#fff'; tctx.fillRect(0,0,40,40);
        tctx.save();
        tctx.translate(20,20);
        tctx.scale(scale, scale);
        tctx.drawImage(design.image, -design.width/2, -design.height/2, design.width, design.height);
        tctx.restore();
        tctx.strokeStyle = '#cbd5e0'; tctx.strokeRect(0,0,40,40);

        item.innerHTML = `
          <img class="design-thumb" src="${thumbCanvas.toDataURL('image/png')}" alt="Miniatura">
          <div>Diseño ${designs.indexOf(design)+1}</div>`;
        item.addEventListener('click', ()=>{
          selectedDesignId = design.id;
          updateDesignsList(); updateControls(); drawCanvas();
          showMessage(`Diseño ${designs.indexOf(design)+1} seleccionado`,'info',2000);
        });
        designsList.appendChild(item);
      });
    }

    // ====== Controles
    function updateControls(){
      const d = getSelectedDesign();
      if (d){
        rotationSlider.value = Math.round(d.rotation);
        rotationInput.value = Math.round(d.rotation);
        rotationValue.textContent = Math.round(d.rotation) + '°';
        opacitySlider.value = Math.round(d.opacity*100);
        opacityValue.textContent = Math.round(d.opacity*100) + '%';
        d.updateInputs();

        [rotationSlider, rotationInput, opacitySlider, removeBtn,
         widthInput, heightInput, applySizeBtn, lockProportion,
         mirrorBtn, bringFrontBtn, sendBackBtn, stepForwardBtn, stepBackBtn
        ].forEach(el=> el && (el.disabled=false));

        updateSizeInfo();
      } else {
        [rotationSlider, rotationInput, opacitySlider, removeBtn,
         widthInput, heightInput, applySizeBtn, lockProportion,
         mirrorBtn, bringFrontBtn, sendBackBtn, stepForwardBtn, stepBackBtn
        ].forEach(el=> el && (el.disabled=true));
        sizeInfo.textContent = '0cm × 0cm';
        originalSizeInfo.textContent = 'Tamaño original: 0cm × 0cm';
      }
    }

    function getSelectedDesign(){
      return designs.find(d=> d.id===selectedDesignId);
    }

    // tamaño manual
    if (applySizeBtn){
      applySizeBtn.addEventListener('click', function(){
        const d = getSelectedDesign();
        if (d){
          const w = parseFloat(widthInput.value);
          const h = parseFloat(heightInput.value);
          if (!isNaN(w) && !isNaN(h) && w>0 && h>0){
            d.setDimensions(w,h, lockProportion.checked);
            showMessage(`Tamaño ajustado a ${w}cm × ${h}cm`, 'success', 2000);
          }
        }
      });
    }

    // sync proporción
    if (lockProportion){
      lockProportion.addEventListener('change', function(){
        const d = getSelectedDesign();
        if (d && this.checked){
          const w = parseFloat(widthInput.value);
          if (!isNaN(w) && w>0){
            heightInput.value = (w / d.aspectRatio).toFixed(1);
          }
        }
        showMessage(this.checked ? 'Proporción bloqueada' : 'Proporción desbloqueada','info',2000);
      });
    }

    if (widthInput){
      widthInput.addEventListener('input', function(){
        if (lockProportion.checked){
          const d = getSelectedDesign();
          if (d){
            const w = parseFloat(this.value);
            if (!isNaN(w) && w>0){
              heightInput.value = (w / d.aspectRatio).toFixed(1);
            }
          }
        }
      });
    }

    if (heightInput){
      heightInput.addEventListener('input', function(){
        if (lockProportion.checked){
          const d = getSelectedDesign();
          if (d){
            const h = parseFloat(this.value);
            if (!isNaN(h) && h>0){
              widthInput.value = (h * d.aspectRatio).toFixed(1);
            }
          }
        }
      });
    }

    // rotación slider
    if (rotationSlider){
      rotationSlider.addEventListener('input', function(){
        const d = getSelectedDesign();
        if (d){
          d.rotation = parseInt(this.value);
          rotationInput.value = this.value;
          rotationValue.textContent = this.value + '°';
          drawCanvas();
        }
      });
    }
    // rotación manual
    if (rotationInput){
      rotationInput.addEventListener('input', function(){
        const d = getSelectedDesign();
        if (d){
          let val = parseInt(this.value);
          if (isNaN(val)) val = 0;
          val = ((val % 360) + 360) % 360;
          d.rotation = val;
          rotationSlider.value = val;
          rotationValue.textContent = val + '°';
          drawCanvas();
        }
      });
    }

    // opacidad
    if (opacitySlider){
      opacitySlider.addEventListener('input', function(){
        const d = getSelectedDesign();
        if (d){
          d.opacity = this.value / 100;
          opacityValue.textContent = this.value + '%';
          drawCanvas();
        }
      });
    }

    // eliminar
    if (removeBtn){
      removeBtn.addEventListener('click', function(){
        const d = getSelectedDesign();
        if (d && confirm('¿Eliminar este diseño?')){
          designs = designs.filter(x=> x.id!==d.id);
          selectedDesignId = designs.length ? designs[designs.length-1].id : null;
          showMessage('Diseño eliminado','info',2000);
          updateDesignsList(); updateControls(); drawCanvas();
        }
      });
    }

    // ====== Zoom con slider
    if (zoomSlider){
      zoomSlider.addEventListener('input', function(){
        canvasZoom = this.value/100;
        zoomValue.textContent = this.value + '%';
        zoomLevel.textContent = 'Zoom: ' + this.value + '%';

        const canvasContainer = document.querySelector('.canvas-area');
        canvasWrapper.style.transform = `scale(${canvasZoom})`;
        canvasContainer.scrollLeft = (canvas.width * canvasZoom - canvasContainer.clientWidth)/2;
        canvasContainer.scrollTop  = (canvas.height* canvasZoom - canvasContainer.clientHeight)/2;
      });
    }

    // ====== Zoom con rueda (Ctrl o ⌘)
    const canvasAreaEl = document.querySelector('.canvas-area');
    if (canvasAreaEl && zoomSlider){
      canvasAreaEl.addEventListener('wheel', (e)=>{
        if (!e.ctrlKey && !e.metaKey) return;
        e.preventDefault();
        const cur = parseInt(zoomSlider.value,10);
        const next = Math.max(20, Math.min(200, cur + (e.deltaY < 0 ? 10 : -10)));
        if (next !== cur){
          zoomSlider.value = String(next);
          zoomSlider.dispatchEvent(new Event('input'));
        }
      }, {passive:false});
    }

    // ====== Agregar texto
    if (addTextBtn){
      addTextBtn.addEventListener('click', function(){
        const text = prompt('Ingresa el texto que deseas agregar:', 'Texto de ejemplo');
        if (text){
          const tCanvas = document.createElement('canvas');
          tCanvas.width = 600; tCanvas.height = 200;
          const tctx = tCanvas.getContext('2d');
          tctx.clearRect(0,0,tCanvas.width,tCanvas.height);
          tctx.fillStyle = '#000000';
          tctx.font = '80px Arial';
          tctx.textAlign = 'center';
          tctx.textBaseline = 'middle';
          tctx.fillText(text, tCanvas.width/2, tCanvas.height/2);

          const img = new Image();
          img.onload = function(){
            const id = 'text-' + Date.now();
            const d = new Design(id, img, canvas.width/2, canvas.height/2);

            const maxW = canvas.width - 20;
            const maxH = canvas.height - 20;
            const scaleToFit = Math.min(maxW / d.width, maxH / d.height);
            d.scale = Math.min(1, scaleToFit);

            designs.push(d); selectedDesignId = id;
            showMessage('Texto agregado correctamente','success',2000);
            updateDesignsList(); updateControls(); drawCanvas();
          };
          img.src = tCanvas.toDataURL('image/png');
        }
      });
    }

    // ====== Exportar PNG
    if (downloadPngBtn){
      downloadPngBtn.addEventListener('click', function(){
        if (designs.length===0){ showMessage('No hay diseños para exportar','error'); return; }
        const loading = showMessage('Preparando descarga PNG...','loading',0);
        setTimeout(()=>{
          try{
            const exportCanvas = createHighQualityCanvas();
            const link = document.createElement('a');
            link.download = 'montaje-dtf.png';
            exportCanvas.toBlob(function(blob){
              link.href = URL.createObjectURL(blob);
              link.click();
              setTimeout(()=>{
                URL.revokeObjectURL(link.href);
                loading.remove();
                showMessage('Descarga PNG completada','success');
              },100);
            }, 'image/png', 1.0);
          } catch(err){
            loading.remove();
            showMessage('Error al generar PNG: ' + err.message, 'error');
          }
        }, 200);
      });
    }

    // ====== Exportar PDF
    if (downloadPdfBtn){
      downloadPdfBtn.addEventListener('click', function(){
        if (designs.length===0){ showMessage('No hay diseños para exportar','error'); return; }
        const loading = showMessage('Preparando descarga PDF...','loading',0);
        setTimeout(()=>{
          try{
            const exportCanvas = createHighQualityCanvas();
            exportCanvas.toBlob(function(blob){
              const reader = new FileReader();
              reader.onload = function(){
                const imgData = reader.result;
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                  orientation: 'portrait',
                  unit: 'mm',
                  format: [CANVAS_WIDTH_CM*10, CANVAS_HEIGHT_CM*10]
                });
                doc.addImage(imgData, 'PNG', 0, 0, CANVAS_WIDTH_CM*10, CANVAS_HEIGHT_CM*10, undefined, 'FAST');
                doc.save('montaje-dtf.pdf');
                loading.remove();
                showMessage('Descarga PDF completada','success');
              };
              reader.readAsDataURL(blob);
            }, 'image/png', 1.0);
          } catch(err){
            loading.remove();
            showMessage('Error al generar PDF: ' + err.message, 'error');
          }
        }, 200);
      });
    }

    // ====== Limpiar lienzo
    if (clearBtn){
      clearBtn.addEventListener('click', function(){
        if (designs.length>0 && confirm('¿Limpiar el lienzo? Se perderán todos los diseños.')){
          designs = []; selectedDesignId = null;
          showMessage('Lienzo limpiado','info',2000);
          updateDesignsList(); updateControls(); initCanvas();
        }
      });
    }

    // ====== Interacción mouse/touch
    function toCanvasCoords(e){
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top)  * scaleY
      };
    }

    canvas.addEventListener('mousedown', function(e){
      const {x, y} = toCanvasCoords(e);
      lastMouseX = x; lastMouseY = y;

      for (let i=designs.length-1; i>=0; i--){
        const d = designs[i];

        if (d.isRotationHandle(x,y)){
          selectedDesignId = d.id; isRotating = true;
          updateDesignsList(); updateControls(); drawCanvas(); return;
        }
        if (d.isScaleHandle(x,y)){
          selectedDesignId = d.id; isResizing = true;
          startScale = d.scale;
          startResizeDist = Math.hypot(x - d.x, y - d.y);
          updateDesignsList(); updateControls(); drawCanvas(); return;
        }
        if (d.isPointInside(x,y)){
          selectedDesignId = d.id; isDragging = true;
          dragOffsetX = x - d.x; dragOffsetY = y - d.y;
          updateDesignsList(); updateControls(); drawCanvas(); return;
        }
      }
      selectedDesignId = null;
      updateDesignsList(); updateControls(); drawCanvas();
    });

    canvas.addEventListener('mousemove', function(e){
      const {x, y} = toCanvasCoords(e);
      const d = getSelectedDesign();
      lastMouseX = x; lastMouseY = y;

      if (isDragging && d){
        d.x = x - dragOffsetX; d.y = y - dragOffsetY;
        drawCanvas();
      } else if (isRotating && d){
        let angle = Math.atan2(y - d.y, x - d.x) * 180 / Math.PI + 90;
        angle = (angle % 360 + 360) % 360;
        d.rotation = angle;
        rotationSlider.value = Math.round(angle);
        rotationInput.value = Math.round(angle);
        rotationValue.textContent = Math.round(angle) + '°';
        drawCanvas();
      } else if (isResizing && d){
        const dist = Math.hypot(x - d.x, y - d.y);
        const factor = dist / Math.max(1, startResizeDist);
        d.scale = startScale * factor;
        d.updateInputs();
        updateSizeInfo();
        drawCanvas();
      }
    });

    ['mouseup','mouseleave'].forEach(ev=>{
      canvas.addEventListener(ev, function(){
        isDragging = false; isResizing = false; isRotating = false;
      });
    });

    // touch
    canvas.addEventListener('touchstart', function(e){
      e.preventDefault();
      const t = e.touches[0];
      canvas.dispatchEvent(new MouseEvent('mousedown', { clientX:t.clientX, clientY:t.clientY }));
    }, {passive:false});
    canvas.addEventListener('touchmove', function(e){
      e.preventDefault();
      const t = e.touches[0];
      canvas.dispatchEvent(new MouseEvent('mousemove', { clientX:t.clientX, clientY:t.clientY }));
    }, {passive:false});
    canvas.addEventListener('touchend', function(e){
      e.preventDefault();
      canvas.dispatchEvent(new MouseEvent('mouseup', {}));
    }, {passive:false});

    // ====== Alto del lienzo (solo alto, máx 100 cm)
    if (applyCanvasHeightBtn){
      applyCanvasHeightBtn.addEventListener('click', function(){
        let newHcm = parseFloat(canvasHeightInput.value);
        if (isNaN(newHcm)) return;
        newHcm = Math.max(10, Math.min(100, newHcm));
        CANVAS_HEIGHT_CM = newHcm;

        const newPx = Math.round(CANVAS_HEIGHT_CM * PIXELS_PER_CM);
        canvas.height = newPx;
        canvasWrapper.style.height = newPx + 'px';

        canvasSizeLabel.textContent = `${CANVAS_WIDTH_CM}cm × ${CANVAS_HEIGHT_CM}cm`;
        specsLabel.textContent = `Lienzo: ${CANVAS_WIDTH_CM}cm × ${CANVAS_HEIGHT_CM}cm | Formato: PNG/PDF`;

        drawCanvas();
        showMessage(`Alto del lienzo ajustado a ${CANVAS_HEIGHT_CM} cm`, 'success', 2000);
      });
    }

    // ====== Atajos de teclado
    document.addEventListener('keydown', function(e){
      const tag = (e.target.tagName || '').toLowerCase();
      if (tag === 'input' || tag === 'textarea') return;

      const d = getSelectedDesign();
      const step = e.shiftKey ? 10 : 1;

      if ((e.key === 'Delete' || e.key === 'Backspace') && d){
        e.preventDefault();
        designs = designs.filter(x=> x.id!==d.id);
        selectedDesignId = designs.length ? designs[designs.length-1].id : null;
        updateDesignsList(); updateControls(); drawCanvas();
        showMessage('Diseño eliminado','info',1500);
        return;
      }

      if (!d) return;

      if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'd')){
        e.preventDefault();
        const id = 'design-' + Date.now() + Math.random().toString(36).slice(2,7);
        const dup = new Design(id, d.image, d.x + 10, d.y + 10);
        dup.scale = d.scale; dup.rotation = d.rotation; dup.opacity = d.opacity;
        designs.push(dup);
        selectedDesignId = id;
        updateDesignsList(); updateControls(); drawCanvas();
        showMessage('Diseño duplicado','success',1200);
        return;
      }

      const arrows = ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'];
      if (arrows.includes(e.key)){
        e.preventDefault();
        if (e.key === 'ArrowLeft')  d.x -= step;
        if (e.key === 'ArrowRight') d.x += step;
        if (e.key === 'ArrowUp')    d.y -= step;
        if (e.key === 'ArrowDown')  d.y += step;
        drawCanvas();
      }
    });

    // ====== ESPEJO (Horizontal)
    if (mirrorBtn){
      mirrorBtn.addEventListener('click', ()=>{
        const d = getSelectedDesign();
        if (!d){ showMessage('Selecciona un diseño para aplicar espejo','warning',1800); return; }

        const tCanvas = document.createElement('canvas');
        tCanvas.width = d.image.width;
        tCanvas.height = d.image.height;
        const tctx = tCanvas.getContext('2d');

        tctx.save();
        tctx.translate(tCanvas.width, 0);
        tctx.scale(-1, 1);
        tctx.imageSmoothingEnabled = true;
        tctx.imageSmoothingQuality = 'high';
        tctx.drawImage(d.image, 0, 0, tCanvas.width, tCanvas.height);
        tctx.restore();

        const img = new Image();
        img.onload = ()=>{ d.image = img; drawCanvas(); showMessage('Espejo aplicado','success',1200); };
        img.src = tCanvas.toDataURL('image/png');
      });
    }

if (removeBgBtn) {
  removeBgBtn.addEventListener('click', async ()=>{
    const d = getSelectedDesign();
    if (!d) { showMessage('Selecciona un diseño primero','warning'); return; }

    // Evitar ejecuciones simultáneas por doble clic
    if (removeBgBtn.__busy) return;
    removeBgBtn.__busy = true;
    removeBgBtn.disabled = true;

    // Preguntar nivel (opcional)
    const nivel = (prompt('Nivel de recorte (suave / medio / fuerte):', 'medio') || 'medio').toLowerCase();
    let opts;
    if (nivel.startsWith('f')) { // fuerte
      opts = { threshold: 0.92, feather: 3, clean: 2 };
    } else if (nivel.startsWith('s')) { // suave
      opts = { threshold: 0.70, feather: 2, clean: 1 };
    } else { // medio
      opts = { threshold: 0.85, feather: 2, clean: 1 };
    }

    let loading;
    try {
      loading = showMessage('Quitando fondo (Beta)...','loading',0);

      // Llamada SECUENCIAL interna (arreglado en la función)
      const cut = await removeBackgroundFromImage(d.image, opts);

      const newImg = new Image();
      newImg.onload = ()=>{
        d.image = newImg;
        drawCanvas();
        if (loading) loading.remove();
        showMessage(`Fondo eliminado (${nivel}) ✅`,'success',2000);
      };
      newImg.src = cut.toDataURL('image/png');
    } catch(err){
      if (loading) loading.remove();
      showMessage('Error al quitar fondo: '+err.message,'error');
    } finally {
      removeBgBtn.__busy = false;
      removeBgBtn.disabled = false;
    }
  });
}



    // ====== Z-ORDER
    function idxSel(){ return designs.findIndex(x=> x.id===selectedDesignId); }
    function refreshAfterZ(){ updateDesignsList(); drawCanvas(); }

    if (bringFrontBtn){
      bringFrontBtn.addEventListener('click', ()=>{
        const i = idxSel(); if (i<0) return;
        const it = designs.splice(i,1)[0];
        designs.push(it);
        refreshAfterZ();
      });
    }
    if (sendBackBtn){
      sendBackBtn.addEventListener('click', ()=>{
        const i = idxSel(); if (i<0) return;
        const it = designs.splice(i,1)[0];
        designs.unshift(it);
        refreshAfterZ();
      });
    }
    if (stepForwardBtn){
      stepForwardBtn.addEventListener('click', ()=>{
        const i = idxSel(); if (i<0 || i===designs.length-1) return;
        [designs[i], designs[i+1]] = [designs[i+1], designs[i]];
        refreshAfterZ();
      });
    }
    if (stepBackBtn){
      stepBackBtn.addEventListener('click', ()=>{
        const i = idxSel(); if (i<=0) return;
        [designs[i-1], designs[i]] = [designs[i], designs[i-1]];
        refreshAfterZ();
      });
    }

    // ====== Barra flotante: reenvía clicks a botones originales (tu código)
    (function(){
      const floatBar = document.getElementById('floating-tools');
      if (!floatBar) return;
      floatBar.addEventListener('click', (e)=>{
        const btn = e.target.closest('button[data-target]');
        if (!btn) return;
        const targetId = btn.getAttribute('data-target');
        const realBtn = document.getElementById(targetId);
        if (realBtn && !realBtn.disabled){
          realBtn.click();
        } else if (realBtn && realBtn.disabled){
          const d = getSelectedDesign();
          if (!d) showMessage('Selecciona un diseño primero', 'warning', 1600);
        }
      });
    })();

    // ====== NUEVO: colocar barra debajo del título automáticamente mientras esté "anclada"
    (function placeFloatBelowTitle(){
      const titleEl = document.querySelector('.canvas-title');
      function update(){
        if (!titleEl) return;
        const h = titleEl.offsetHeight || 0;
        document.documentElement.style.setProperty('--title-h', h + 'px');
      }
      window.addEventListener('load', update);
      window.addEventListener('resize', update);
      if ('ResizeObserver' in window && titleEl){
        const ro = new ResizeObserver(update);
        ro.observe(titleEl);
      } else {
        // fallback sencillo
        setInterval(update, 500);
      }
      update();
    })();

    // ====== NUEVO: hacer la barra arrastrable + recordar posición + doble click para reset
    (function makeFloatingToolsDraggable(){
      const bar = document.getElementById('floating-tools');
      const container = document.querySelector('.canvas-container');
      if (!bar || !container) return;

      // Estado de posicionamiento: 'docked' (anclada) o 'free' (libre)
      function loadPos(){
        try { return JSON.parse(localStorage.getItem('dtf_float_pos') || '{}'); }
        catch { return {}; }
      }
      function savePos(obj){
        localStorage.setItem('dtf_float_pos', JSON.stringify(obj || {}));
      }

      const saved = loadPos();
      if (typeof saved.top === 'number' && typeof saved.left === 'number'){
        // compatibilidad con versión anterior: asumir modo libre
        bar.style.top = saved.top + 'px';
        bar.style.left = saved.left + 'px';
        bar.style.right = 'auto';
        savePos({ mode:'free', top:saved.top, left:saved.left });
      } else if (saved.mode === 'free'){
        if (typeof saved.top === 'number')  bar.style.top  = saved.top + 'px';
        if (typeof saved.left === 'number') bar.style.left = saved.left + 'px';
        bar.style.right = 'auto';
      } // si no hay guardado, queda en 'docked' usando el CSS (top calculado con --title-h)

      let startX=0, startY=0, startLeft=0, startTop=0, dragging=false;

      function clamp(val, min, max){ return Math.max(min, Math.min(max, val)); }

      function getBarRectRel(){
        const cont = container.getBoundingClientRect();
        const rect = bar.getBoundingClientRect();
        return {
          left: rect.left - cont.left + container.scrollLeft,
          top : rect.top  - cont.top  + container.scrollTop,
          width: rect.width,
          height: rect.height,
          contW: cont.width,
          contH: cont.height
        };
      }

      function onPointerDown(e){
        // Si clickea un botón, deja pasar el click normal
        if (e.target.closest('button[data-target]')) return;
        dragging = true;
        const r = getBarRectRel();
        startX = e.clientX; startY = e.clientY;
        startLeft = r.left; startTop = r.top;

        bar.setPointerCapture?.(e.pointerId);
        e.preventDefault();
      }

      function onPointerMove(e){
        if (!dragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        const r = getBarRectRel();
        const maxLeft = r.contW - r.width - 6;
        const maxTop  = r.contH - r.height - 6;

        const nextLeft = clamp(startLeft + dx, 6, Math.max(6, maxLeft));
        const nextTop  = clamp(startTop  + dy, 6, Math.max(6, maxTop));

        // Cambiar a modo libre
        bar.style.left = nextLeft + 'px';
        bar.style.top  = nextTop  + 'px';
        bar.style.right = 'auto';

        savePos({ mode:'free', top: nextTop, left: nextLeft });
      }

      function onPointerUp(){
        dragging = false;
      }

      // Doble click: resetear a "anclada" (debajo del título)
      bar.addEventListener('dblclick', ()=>{
        bar.style.left = '';
        bar.style.top  = '';
        bar.style.right = ''; // vuelve a usar right: 10px desde CSS
        savePos({ mode:'docked' });
        showMessage('Barra reposicionada debajo del título','info',1500);
      });

      bar.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      window.addEventListener('pointercancel', onPointerUp);

      // Re-clampear en resize si está en modo libre
      window.addEventListener('resize', ()=>{
        const s = loadPos();
        if (s.mode !== 'free') return;
        const r = getBarRectRel();
        const maxLeft = r.contW - r.width - 6;
        const maxTop  = r.contH - r.height - 6;
        const newLeft = clamp(parseInt(bar.style.left||'0',10), 6, Math.max(6, maxLeft));
        const newTop  = clamp(parseInt(bar.style.top ||'0',10),  6, Math.max(6, maxTop));
        bar.style.left = newLeft + 'px';
        bar.style.top  = newTop + 'px';
        savePos({ mode:'free', top:newTop, left:newLeft });
      });
    })();

// ===== MOCKUPS (multi-capa): refs y estado =====
const openMockupsBtn = document.getElementById('open-mockups');
const mockPane     = document.getElementById('mockup-pane');
const mockStage    = document.getElementById('mock-stage');
const mockTemplate = document.getElementById('mock-template');
const mockHost     = document.getElementById('mock-layer-host');

const mockTemplateSelect = document.getElementById('mock-template-select');
const mockBlend    = document.getElementById('mock-blend');
const mockOpacity  = document.getElementById('mock-opacity');
const mockScale    = document.getElementById('mock-scale');
const mockRot      = document.getElementById('mock-rot');

const mockUploadBtn= document.getElementById('mock-upload');
const mockFile     = document.getElementById('mock-file');
const mockUseSelectedBtn = document.getElementById('mock-use-selected');
const mockDeleteBtn  = document.getElementById('mock-delete');
const mockFrontBtn   = document.getElementById('mock-front');
const mockBackBtn    = document.getElementById('mock-back');
const mockDownloadBtn= document.getElementById('mock-download');
const mockCloseBtn   = document.getElementById('mock-close');

const mockLayersList = document.getElementById('mock-layers-list');

let mockState = {
  templateLoaded: false,
  layers: [],           // [{el, src, x, y, scale, rot, blend, opacity}]
  active: -1            // índice de capa seleccionada
};

// ===== TUS PLANTILLAS (i.ibb.co enlaces directos) =====
const MOCK_TEMPLATES = [
  { name: 'Camiseta Blanca', url: 'https://i.ibb.co/9kDxHZyY/camiseta-blanca.png' },
  { name: 'Camiseta Negra',  url: 'https://i.ibb.co/8DwDJ6xZ/camiseta-negra.png' },
  { name: 'Camiseta Gris',   url: 'https://i.ibb.co/9V0b9mB/tee-gray.png' }
];
function fillMockTemplateSelect(){
  mockTemplateSelect.innerHTML = '';
  MOCK_TEMPLATES.forEach((t, i)=>{
    const opt = document.createElement('option');
    opt.value = String(i);
    opt.textContent = t.name;
    mockTemplateSelect.appendChild(opt);
  });
}
fillMockTemplateSelect();

function loadImageCORS(src){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = ()=> resolve(img);
    img.onerror = ()=> reject(new Error('No se pudo cargar: ' + src));
    img.src = src;
  });
}

// Abrir/Cerrar panel
if (openMockupsBtn){
  openMockupsBtn.addEventListener('click', async ()=>{
    mockPane.style.display = 'block';
    showMessage('Panel de Mockups abierto','info',1500);
    try{
      const idx = parseInt(mockTemplateSelect.value || '0', 10) || 0;
      await setMockTemplate(MOCK_TEMPLATES[idx].url);
    }catch(err){ showMessage(err.message, 'error'); }
  });
}
mockCloseBtn?.addEventListener('click', ()=> mockPane.style.display='none');

// Cambiar plantilla
mockTemplateSelect.addEventListener('change', async ()=>{
  const idx = parseInt(mockTemplateSelect.value, 10);
  if (isNaN(idx)) return;
  const url = MOCK_TEMPLATES[idx]?.url;
  if (!url) return;
  try{ await setMockTemplate(url); }catch(err){ showMessage(err.message,'error'); }
});

async function setMockTemplate(url){
  const img = await loadImageCORS(url);
  mockTemplate.src = img.src;
  mockTemplate.style.width = '100%';
  mockTemplate.style.height = 'auto';
  mockState.templateLoaded = true;
}

// ===== Capas: helpers =====
function addLayerFromSrc(src, opts={}){
  const el = document.createElement('img');
  el.className = 'mock-design';
  el.draggable = false;
  el.alt = 'Capa';
  el.src = src;

  // Estado por defecto
  const layer = {
    el,
    src,
    x: opts.x ?? 0.5,
    y: opts.y ?? 0.5,
    scale: opts.scale ?? 1.0,
    rot: opts.rot ?? 0,
    blend: opts.blend ?? (mockBlend.value || 'multiply'),
    opacity: opts.opacity ?? (parseInt(mockOpacity.value,10)/100 || 0.95)
  };

  // base visual coherente
  el.style.width = '50%';

  mockHost.appendChild(el);
  mockState.layers.push(layer);
  selectLayer(mockState.layers.length - 1);
  applyLayerStyle(layer);
  rebuildLayersList();
  enableDragFor(el);
  showMessage('Capa añadida','success',1200);
}

function selectLayer(index){
  // deseleccionar visualmente
  mockState.layers.forEach(l=> l.el.classList.remove('selected'));
  mockState.active = index;
  const L = mockState.layers[index];
  if (L){
    L.el.classList.add('selected');
    // sincroniza controles globales con la capa activa
    mockBlend.value = L.blend === 'source-over' ? 'normal' : L.blend;
    mockOpacity.value = Math.round((L.opacity ?? 1)*100);
    mockScale.value = Math.round(L.scale * 100);
    mockRot.value = Math.round(L.rot || 0);
  }
  rebuildLayersList();
}

function removeActiveLayer(){
  const i = mockState.active;
  if (i<0) return;
  const [L] = mockState.layers.splice(i,1);
  L?.el?.remove();
  const next = Math.min(i, mockState.layers.length-1);
  selectLayer(next);
  rebuildLayersList();
  showMessage('Capa eliminada','info',1200);
}

function moveActiveToFront(){
  const i = mockState.active;
  if (i<0 || i===mockState.layers.length-1) return;
  const [L] = mockState.layers.splice(i,1);
  mockState.layers.push(L);
  mockHost.appendChild(L.el); // último = al frente
  selectLayer(mockState.layers.length-1);
  rebuildLayersList();
}

function moveActiveToBack(){
  const i = mockState.active;
  if (i<=0) return;
  const [L] = mockState.layers.splice(i,1);
  mockState.layers.unshift(L);
  mockHost.insertBefore(L.el, mockHost.firstChild);
  selectLayer(0);
  rebuildLayersList();
}

function rebuildLayersList(){
  mockLayersList.innerHTML = '';
  if (mockState.layers.length===0){
    mockLayersList.innerHTML = '<div class="no-designs">No hay capas aún</div>';
    return;
  }
  mockState.layers.forEach((L, idx)=>{
    const item = document.createElement('div');
    item.className = 'design-item' + (idx===mockState.active ? ' active' : '');
    item.innerHTML = `
      <img class="design-thumb" src="${L.src}">
      <div>Capa ${idx+1}</div>
    `;
    item.addEventListener('click', ()=> selectLayer(idx));
    mockLayersList.appendChild(item);
  });
}

function applyLayerStyle(L){
  const rect = mockStage.getBoundingClientRect();
  const dx = L.x * rect.width;
  const dy = L.y * rect.height;

  L.el.style.left = dx + 'px';
  L.el.style.top  = dy + 'px';
  L.el.style.transform = `translate(-50%,-50%) rotate(${L.rot||0}deg) scale(${L.scale||1})`;
  L.el.style.mixBlendMode = (L.blend === 'source-over' ? 'normal' : L.blend) || 'multiply';
  L.el.style.opacity = String(L.opacity ?? 0.95);
}

function enableDragFor(el){
  let dragging=false, startX=0, startY=0, startLeft=0, startTop=0;
  function getPoint(e){
    if (e.touches && e.touches[0]) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
    return { x:e.clientX, y:e.clientY };
  }
  function rectHalf(el){
    const r = el.getBoundingClientRect();
    return { w:r.width/2, h:r.height/2 };
  }
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  el.addEventListener('mousedown', (e)=>{
    const idx = mockState.layers.findIndex(L=> L.el === el);
    if (idx>=0) selectLayer(idx);
    dragging = true;
    const pt = getPoint(e);
    startX = pt.x; startY = pt.y;
    const r = el.getBoundingClientRect();
    startLeft = r.left; startTop = r.top;
    e.preventDefault();
  });
  window.addEventListener('mousemove', (e)=>{
    if (!dragging) return;
    const L = mockState.layers[mockState.active]; if (!L) return;
    const pt = getPoint(e);
    const dx = pt.x - startX;
    const dy = pt.y - startY;

    const stageRect = mockStage.getBoundingClientRect();
    const half = rectHalf(el);
    const newCX = (startLeft + dx) + half.w;
    const newCY = (startTop  + dy) + half.h;

    L.x = clamp((newCX - stageRect.left) / stageRect.width , 0, 1);
    L.y = clamp((newCY - stageRect.top ) / stageRect.height, 0, 1);
    applyLayerStyle(L);
  });
  window.addEventListener('mouseup', ()=> dragging=false);

  // Touch
  el.addEventListener('touchstart', (e)=>{
    const idx = mockState.layers.findIndex(L=> L.el === el);
    if (idx>=0) selectLayer(idx);
    dragging = true;
    const pt = getPoint(e);
    startX = pt.x; startY = pt.y;
    const r = el.getBoundingClientRect();
    startLeft = r.left; startTop = r.top;
    e.preventDefault();
  }, {passive:false});
  window.addEventListener('touchmove', (e)=>{
    if (!dragging) return;
    const L = mockState.layers[mockState.active]; if (!L) return;
    const pt = getPoint(e);
    const dx = pt.x - startX;
    const dy = pt.y - startY;

    const stageRect = mockStage.getBoundingClientRect();
    const half = rectHalf(el);
    const newCX = (startLeft + dx) + half.w;
    const newCY = (startTop  + dy) + half.h;

    L.x = Math.max(0, Math.min(1, (newCX - stageRect.left) / stageRect.width ));
    L.y = Math.max(0, Math.min(1, (newCY - stageRect.top ) / stageRect.height));
    applyLayerStyle(L);
  }, {passive:false});
  window.addEventListener('touchend', ()=> dragging=false);
}

// ===== Añadir capas =====
mockUploadBtn.addEventListener('click', ()=> mockFile.click());
mockFile.addEventListener('change', (e)=>{
  if (!e.target.files || e.target.files.length===0) return;
  const file = e.target.files[0];
  const reader = new FileReader();
  reader.onload = ()=>{
    addLayerFromSrc(reader.result, { scale: 1.0, rot: 0 });
  };
  reader.readAsDataURL(file);
});

mockUseSelectedBtn.addEventListener('click', ()=>{
  const d = getSelectedDesign();
  if (!d){ showMessage('Selecciona un diseño en el editor', 'warning', 1800); return; }
  const temp = document.createElement('canvas');
  temp.width = d.image.width; temp.height = d.image.height;
  const tctx = temp.getContext('2d');
  tctx.imageSmoothingEnabled = true; tctx.imageSmoothingQuality = 'high';
  tctx.drawImage(d.image, 0, 0, temp.width, temp.height);
  addLayerFromSrc(temp.toDataURL('image/png'), { scale: 1.0, rot: d.rotation||0 });
});

// ===== Controles aplican a la capa activa =====
mockBlend.addEventListener('change', ()=>{
  const L = mockState.layers[mockState.active]; if (!L) return;
  L.blend = (mockBlend.value === 'normal') ? 'source-over' : mockBlend.value;
  applyLayerStyle(L);
});
mockOpacity.addEventListener('input', ()=>{
  const L = mockState.layers[mockState.active]; if (!L) return;
  L.opacity = parseInt(mockOpacity.value, 10)/100;
  applyLayerStyle(L);
});
mockScale.addEventListener('input', ()=>{
  const L = mockState.layers[mockState.active]; if (!L) return;
  L.scale = parseInt(mockScale.value, 10)/100;
  applyLayerStyle(L);
});
mockRot.addEventListener('input', ()=>{
  const L = mockState.layers[mockState.active]; if (!L) return;
  L.rot = parseInt(mockRot.value, 10) || 0;
  applyLayerStyle(L);
});

// Eliminar / Z-order
mockDeleteBtn.addEventListener('click', removeActiveLayer);
mockFrontBtn.addEventListener('click', moveActiveToFront);
mockBackBtn.addEventListener('click', moveActiveToBack);

// Tecla Supr en el panel
document.addEventListener('keydown', (e)=>{
  if (mockPane.style.display !== 'block') return;
  if (['INPUT','SELECT','TEXTAREA'].includes((e.target.tagName||'').toUpperCase())) return;
  if ((e.key === 'Delete' || e.key === 'Backspace') && mockState.active>=0){
    e.preventDefault();
    removeActiveLayer();
  }
});

// ===== Descargar PNG del mockup (todas las capas, tamaños reales) =====
mockDownloadBtn.addEventListener('click', async ()=>{
  if (!mockState.templateLoaded){
    showMessage('Carga una plantilla primero','warning',2000); return;
  }
  if (mockState.layers.length===0){
    showMessage('Agrega al menos una capa','warning',2000); return;
  }

  const stageRect = mockStage.getBoundingClientRect();
  const W = Math.max(2, Math.round(stageRect.width * 2)); // 2x nitidez
  const H = Math.max(2, Math.round(stageRect.height * 2));
  const c = document.createElement('canvas'); c.width = W; c.height = H;
  const x = c.getContext('2d');
  x.imageSmoothingEnabled = true; x.imageSmoothingQuality = 'high';

  // 1) Plantilla
  const tplImg = await loadImageCORS(mockTemplate.src);
  x.drawImage(tplImg, 0, 0, W, H);

  // 2) Capas (en orden, de fondo a frente)
  for (const L of mockState.layers){
    const img = await loadImageCORS(L.src);

    // ancho/alto visibles del <img> en pantalla
    const elRect = L.el.getBoundingClientRect();
    const sx = W / stageRect.width;
    const dw = Math.max(1, Math.round(elRect.width  * sx));
    const dh = Math.max(1, Math.round(elRect.height * sx));

    const cx = L.x * W;
    const cy = L.y * H;

    x.save();
    x.globalAlpha = L.opacity ?? 1;
    x.globalCompositeOperation = L.blend || 'source-over';
    x.translate(cx, cy);
    x.rotate((L.rot||0) * Math.PI/180);
    x.scale(L.scale || 1, L.scale || 1);
    // OJO: ya incluimos scale en CSS (al medir el rect). Para evitar doble escala,
    // dibujamos el tamaño base sin volver a multiplicar por L.scale en dw/dh.
    // Por eso aquí el .scale() sí se usa y dw/dh vienen del tamaño visual sin scale CSS.
    x.drawImage(img, -dw/2, -dh/2, dw, dh);
    x.restore();
  }

  c.toBlob(blob=>{
    const a = document.createElement('a');
    a.download = 'mockup-camiseta.png';
    a.href = URL.createObjectURL(blob);
    a.click();
    setTimeout(()=> URL.revokeObjectURL(a.href), 2000);
  }, 'image/png', 1.0);
});

    // ====== Iniciar controles
    updateControls();
    setTimeout(()=> showMessage('¡Bienvenido al Editor DTF! Sube tus diseños para comenzar.','info'), 800);
  </script>
</body>
</html>
